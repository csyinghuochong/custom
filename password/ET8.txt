childof( parent )
public class son   //实体必须指明父实体


[componentof(typeof(scene))]
public class com   组件必须指明父实体的类型//


[entitysystemof(typeof(com))]  //扩展方法

friendof(com) 访问该类的方法


init.start.  CodeLoader开始分发（客户端。服务器）

Entry.Start  (前后端公用)


World.Instance.AddSingleton<ObjectPool>();

 // 创建需要reload的code singleton
 CodeTypes.Instance.CreateCode();

Fiber.Scene(Robot)  组件都是挂到scene上的

Fiber 是因为多线程多进程的原因  可以有很多个fiber

Fiber的public EntitySystem EntitySystem { get; }  驱动所有组件和子实体的生命周期函数

 public enum SchedulerType
 {
     Main,                //主线程就是队列循环调用
     Thread,            //固定线程调用 ，每个线程一个Fiber
     ThreadPool,    //线程池调用， 同一个Fiber只会在同一个时间段随机被某一个线程调用
 }
Fiber 生命周期的三种调用方式
Fiber和Fiber之间完全隔壁， 多个cpu驱动多个线程，多个线程驱动多个fiber

Fiber 和 Scene 相互引用

客户端一般只有两个Fiber(业务逻辑) Fiber(网络消息)

Scene是最近的Scene, robot是根Scene.


ET 公用  ET.Server 服务器用 ET.client 客户端用  EventType 必须放在allmodel



 [Event(SceneType.Demo)]    传入sceneType  只有处理该scenetype


#if DOTNET  服务器

研究一下 Fiber.Update 的三种调度方式 

LS开头的是帧同步

事件的处理不涉及到任何显示层 则放在hotfix下面

ActorId 指明了actor所在的进程和fider


DBComponent 加入到对应的scene

返回一个四元数，该四元数表示绕单位轴旋转一个以弧度为单位的角度。
quaternion.AxisAngle(math.up() , skillcmd.TargetAngle / 57.3f );

math.degrees()                                 弧度转角度
math.radians(skillcmd.TargetAngle)   角度转弧度


NetComponent  注意一下两个组件
  // 挂上这个组件，5秒就会删除session，所以客户端验证完成要删除这个组件。该组件的作用就是防止外挂一直连接不发消息也不进行权限验证
session.AddComponent<SessionAcceptTimeoutComponent>();
// 客户端连接，2秒检查一次recv消息，10秒没有消息则断开
  session.AddComponent<SessionIdleCheckerComponent>();

登陆流程
C2R_LoginAccount   -> (Realm) tokenComponent.Add(centerAccountInfo.Account, Token, true);
C2R_GetRealmKey->    R2G_GetLoginKey->(Gate) scene.GetComponent<GateSessionKeyComponent>().Add(key.GetLongHashCode(), request.Account); ->return key gateadress
C2G_LoginGameGate ->



~    位逻辑非运算  如果某一位等于0，就将其转变为1；如果某一位等于1，就将其转变为0。   
^    位逻辑异或运算将两个运算对象按位进行异或运算。异或运算的规则是：1异或1等于0，1异或0等于1，0异或0等于0。即：相同得0，相异得1。  比如：10010001（二进制）^11110000（二进制）等于01100001（二进制）。
&    它用于对操作数的每一位进行按位与操作。‌如果两个相应的二进制位都为1，‌则该位的结果值为1；‌否则，‌结果值为0。‌例如，‌在二进制中执行1101010 & 1001010将得到结果1001010
|     比如10010001（二进制）| 11110000（二进制）等于11110001（二进制）。
<<    位左移运算  byte a=0x65(即二进制的01100101),将其左移3位：a<<3的结果是0x27(即二进制的00101000)。


UI系统框架, 以uipet举例
ModelView   	 DlgPet                                             	View{ public DlgPetViewComponent View }
UIBehaviour              DlgPetViewComponent                    	public Transform uiTransform = null;   

HotfixView                DlgPetSystem   			RegisterUIEvent   ShowWindow   {  self.View.ES_PetHeCheng.OnHeChengReturn(); }   逻辑全部写在这
                                 DlgPetEventHandler  		OnInitWindowCoreData / OnInitComponent / OnShowWindow / uiBaseWindow.AddComponent<DlgMain>().AddComponent<DlgPetViewComponent>(); 只有几个生命周期函数
UIBehaviour              DlgPetViewComponentSystem		self.DestroyWidget(); self.Awake 只有几个生命周期函数


//UIComponent.ShowWindow
 if (self.IScene is Room)
            {
                go = await self.Scene<Room>().GetComponent<ResourcesLoaderComponent>().LoadAssetAsync<GameObject>(value.StringToAB());
            }
            else
            {
                go = await self.Scene<Scene>().GetComponent<ResourcesLoaderComponent>().LoadAssetAsync<GameObject>(value.StringToAB());
            }
            baseWindow.UIPrefabGameObject      = UnityEngine.Object.Instantiate(go);
            baseWindow.UIPrefabGameObject.name = go.name;
            
            UIEventComponent.Instance.GetUIEventHandler(baseWindow.WindowID).OnInitWindowCoreData(baseWindow);
            
            baseWindow?.SetRoot(EUIRootHelper.GetTargetRoot(self.Root(),baseWindow.windowType));
            baseWindow.uiTransform.SetAsLastSibling();
            
            UIEventComponent.Instance.GetUIEventHandler(baseWindow.WindowID).OnInitComponent(baseWindow);
            UIEventComponent.Instance.GetUIEventHandler(baseWindow.WindowID).OnRegisterUIEvent(baseWindow);


Entity contextData = showData == null ? null : showData;
baseWindow.UIPrefabGameObject?.SetActive(true);
UIEventComponent.Instance.GetUIEventHandler(id).OnShowWindow(baseWindow,contextData);


LoopScrollRectBase : UIBehaviour, IInitializePotentialDragHandler, IBeginDragHandler, IEndDragHandler, IDragHandler, IScrollHandler, ICanvasElement, ILayoutElement, ILayoutGroup

LoopScrollRect : LoopScrollRectBase
LoopVerticalScrollRect : LoopScrollRect
LoopHorizontalScrollRect : LoopScrollRect

LoopScrollRectMulti : LoopScrollRectBase
LoopHorizontalScrollRectMulti : LoopScrollRectMulti   （UI/Loop Horizontal Scroll Rect(MultiPrefab)）
LoopVerticalScrollRectMulti : LoopScrollRectMulti
